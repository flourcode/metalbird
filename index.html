<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>SKY DASHBOARD GPU</title>
    
    <script src="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.css" rel="stylesheet" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <style>
        /* === RESET & BASE === */
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: #000;
            color: #fff;
            font-family: 'Space Mono', monospace;
            height: 100vh; height: 100dvh;
            overflow: hidden; position: fixed; width: 100%;
        }

        /* === MAP CONTAINER === */
        #map { position: fixed; inset: 0; z-index: 0; background: #000; }
        
        .maplibregl-canvas {
            filter: grayscale(50%) invert(100%) sepia(50%) hue-rotate(70deg) saturate(80%) brightness(0.7) contrast(1.2);
        }
        
        .maplibregl-ctrl { display: none !important; }

        /* === HUD LAYOUT (CORNERS) === */
        .hud-container {
            position: fixed; inset: 0; z-index: 20; pointer-events: none;
            padding: clamp(20px, 4vw, 40px);
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }

        /* CORNER: TOP LEFT (Time/Date) */
        .hud-tl { align-self: start; justify-self: start; text-align: left; }
        .dash-time {
            font-size: clamp(40px, 8vw, 80px);
            font-weight: 700; line-height: 0.9;
            letter-spacing: -2px;
            color: #f1f8e980;
        }
        .dash-date {
            font-size: clamp(12px, 2vw, 16px);
            font-weight: 400; margin-top: 6px;
            text-transform: uppercase; letter-spacing: 1px;
            color: #a8c25680;
        }

        /* CORNER: TOP RIGHT (Weather) */
        .hud-tr { align-self: start; justify-self: end; text-align: right; }
        .wx-temp { font-size: clamp(32px, 6vw, 60px); font-weight: 700; line-height: 0.9; color: #f1f8e980; }
        .wx-details { font-size: clamp(10px, 1.5vw, 14px); color: #a8c25680; margin-top: 6px; }

        /* CORNER: BOTTOM LEFT (Geo/Status) */
        .hud-bl { align-self: end; justify-self: start; text-align: left; }
        .geo-loc { font-size: clamp(10px, 1.5vw, 14px); letter-spacing: 1px; font-weight: 700; color: #f1f8e980; }
        .plane-count { font-size: 10px; color: #a8c25680; margin-top: 4px; }

        /* CORNER: BOTTOM RIGHT (Settings) */
        .hud-br { align-self: end; justify-self: end; pointer-events: auto; }
        .settings-btn {
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(255,255,255,0.15); color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: transform 0.2s;
        }
        .settings-btn:active { transform: scale(0.9); background: #fff; color: #000; }

        /* === TARGET DATA CARD (CENTER) === */
        .target-card {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 90%; max-width: 380px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 24px;
            z-index: 100;
            display: none; opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
        }
        .target-card.active { display: block; opacity: 1; transform: translate(-50%, -50%) scale(1); }

        .t-label { font-size: 10px; color: #666; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 8px; }
        .t-callsign { font-size: 42px; font-weight: 700; line-height: 0.9; margin-bottom: 4px; letter-spacing: -2px;}
        .t-type { font-size: 13px; color: #a8c256; margin-bottom: 24px; text-transform: uppercase; letter-spacing: 1px; font-weight: 700;}

        .t-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; text-align: left; }
        .t-item { background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; }
        .t-val { font-size: 18px; font-weight: 700; font-variant-numeric: tabular-nums; color: #fff; }
        .t-unit { font-size: 9px; color: #888; margin-top: 2px; }
        
        /* New Phase Box */
        .t-phase-box { grid-column: span 2; text-align: center; border: 1px solid rgba(168, 194, 86, 0.3); }
        .t-phase-val { color: #a8c256; letter-spacing: 2px; }

        .close-target {
            margin-top: 24px;
            background: #fff; color: #000;
            border: none; padding: 14px 32px;
            font-family: 'Space Mono'; font-weight: 700; font-size: 14px;
            border-radius: 30px; cursor: pointer;
        }

        /* === MARKERS === */
        .user-marker {
            width: 40px; height: 40px;
            background: #f1f8e980; 
            border-radius: 50%; border: none; 
            position: relative; z-index: 200;
        }

        /* === SETTINGS PANEL === */
        .settings-panel {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 300; display: none; align-items: center; justify-content: center;
        }
        .settings-panel.open { display: flex; }
        .radius-opt { padding: 16px; font-size: 24px; color: #555; cursor: pointer; transition: 0.2s; }
        .radius-opt:hover { color: #fff; }
        .radius-opt.selected { color: #a8c256; font-weight: 700; transform: scale(1.1); }

        /* === START SCREEN === */
        .start-overlay {
            position: fixed; inset: 0; z-index: 500; background: #000;
            display: flex; align-items: center; justify-content: center;
        }
        .start-btn {
            background: #a8c256; color: #000; border: none;
            padding: 20px 40px; font-family: 'Space Mono'; font-weight: 700;
            font-size: 18px; cursor: pointer; border-radius: 4px;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div class="hud-container">
        <div class="hud-tl">
            <div class="dash-time" id="clockTime">--:--</div>
            <div class="dash-date" id="clockDate">INITIALIZING</div>
        </div>
        <div class="hud-tr">
            <div class="wx-temp" id="wxTemp">--°</div>
            <div class="wx-details">
                <span id="wxCond">LOADING</span><br>
                WIND <span id="wxWind">--</span> KT
            </div>
        </div>
        <div class="hud-bl">
            <div class="geo-loc" id="geoLoc">WAITING FOR GPS</div>
            <div class="plane-count" id="planeCountStatus">RADAR OFFLINE</div>
        </div>
        <div class="hud-br">
            <button class="settings-btn" id="settingsBtn">⚙</button>
        </div>
    </div>

    <div class="target-card" id="targetCard">
        <div class="t-label">LIVE TRACKING</div>
        <div class="t-callsign" id="tCall">N/A</div>
        <div class="t-type" id="tType">UNKNOWN</div>
        
        <div class="t-grid">
            <div class="t-item">
                <div class="t-label">ALTITUDE</div>
                <div class="t-val"><span id="tAlt">0</span></div>
                <div class="t-unit">FEET</div>
            </div>
            <div class="t-item">
                <div class="t-label">DISTANCE</div>
                <div class="t-val"><span id="tDist">0.0</span></div>
                <div class="t-unit">MILES</div>
            </div>
            <div class="t-item">
                <div class="t-label">SPEED</div>
                <div class="t-val"><span id="tSpd">0</span></div>
                <div class="t-unit">KNOTS</div>
            </div>
            <div class="t-item">
                <div class="t-label">HEADING</div>
                <div class="t-val"><span id="tHdg">000</span>°</div>
                <div class="t-unit">TRUE</div>
            </div>
            <div class="t-item t-phase-box">
                <div class="t-label" style="color:#a8c256;">FLIGHT PHASE</div>
                <div class="t-val t-phase-val" id="tPhase">--</div>
            </div>
        </div>
        
        <button class="close-target" onclick="closeTarget()">RETURN TO MAP</button>
    </div>

    <div class="settings-panel" id="settingsPanel">
        <div style="text-align:center;">
            <div style="color:#888; margin-bottom:30px; font-size: 12px; letter-spacing: 2px;">RADAR RANGE</div>
            <div class="radius-opt" onclick="setRadius(3)">3 MILES</div>
            <div class="radius-opt" onclick="setRadius(5)">5 MILES</div>
            <div class="radius-opt" onclick="setRadius(10)">10 MILES</div>
            <div class="radius-opt" onclick="setRadius(25)">25 MILES</div>
            <button onclick="toggleSettings()" style="margin-top:50px; background:none; border:1px solid #333; color:#fff; padding:12px 32px; cursor:pointer; border-radius: 30px;">CLOSE</button>
        </div>
    </div>

    <div class="start-overlay" id="startScreen">
        <button class="start-btn" onclick="startApp()">INITIALIZE SYSTEM</button>
    </div>

    <script>
        const CONFIG = {
            API_PLANES: 'https://api.airplanes.live/v2/point/',
            API_WX_POINTS: 'https://api.weather.gov/points/',
            RADAR_TILE_URL: 'https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png',
            MAP_TILES: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
            POLL_MS: 5000
        };

        const state = {
            lat: null, lon: null,
            radius: 5,
            map: null,
            userMarker: null,
            planesData: new Map(),
            selectedHex: null, 
            wxInterval: null,
            planeInterval: null
        };

        function startApp() {
            document.getElementById('startScreen').style.display = 'none';
            
            // VOICE WELCOME
            speak("Initializing system checks. Please standby.");

            initClock();
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(
                    (pos) => {
                        state.lat = pos.coords.latitude;
                        state.lon = pos.coords.longitude;
                        document.getElementById('geoLoc').textContent = `${state.lat.toFixed(4)} N / ${state.lon.toFixed(4)} W`;
                        if (!state.map) initMap();
                        else {
                            if(!state.selectedHex) state.map.jumpTo({ center: [state.lon, state.lat] });
                            if(state.userMarker) state.userMarker.setLngLat([state.lon, state.lat]);
                        }
                        if (!state.planeInterval) {
                            updateWeather();
                            fetchPlanes();
                            state.wxInterval = setInterval(updateWeather, 900000); 
                            state.planeInterval = setInterval(fetchPlanes, CONFIG.POLL_MS);
                            requestAnimationFrame(animatePlanes); 
                        }
                    }, 
                    (err) => alert("GPS Required. Please allow access."),
                    { enableHighAccuracy: true }
                );
            } else {
                alert("GPS Not Supported");
            }
        }

        function initClock() {
            const update = () => {
                const now = new Date();
                const h = now.getHours().toString().padStart(2, '0');
                const m = now.getMinutes().toString().padStart(2, '0');
                document.getElementById('clockTime').textContent = `${h}:${m}`;
                const opts = { weekday: 'long', month: 'short', day: 'numeric' };
                document.getElementById('clockDate').textContent = now.toLocaleDateString('en-US', opts);
            };
            setInterval(update, 1000);
            update();
        }

        function initMap() {
            try {
                state.map = new maplibregl.Map({
                    container: 'map',
                    style: {
                        version: 8,
                        sources: {
                            'osm': { type: 'raster', tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'], tileSize: 256 }
                        },
                        layers: [
                            { id: 'osm-layer', type: 'raster', source: 'osm' }
                        ],
                        glyphs: "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf"
                    },
                    center: [state.lon, state.lat],
                    zoom: getZoomForRadius(state.radius),
                    attributionControl: false,
                    interactive: true
                });

                state.map.on('load', () => {
                    state.map.addSource('radar', {
                        type: 'raster',
                        tiles: [CONFIG.RADAR_TILE_URL],
                        tileSize: 256
                    });
                    
                    state.map.addLayer({
                        id: 'radar-layer',
                        type: 'raster',
                        source: 'radar',
                        paint: { 'raster-opacity': 0.5, 'raster-fade-duration': 0 }
                    });

                    // --- 1. DRAW PLANE ICON (PRE-INVERTED FOR FILTER) ---
                    const width = 64, height = 64;
                    const canvas = document.createElement('canvas');
                    canvas.width = width; canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.font = 'bold 50px sans-serif';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#000000'; // Black -> white after invert -> cream after other filters
                    ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 2;
                    ctx.translate(width/2, height/2); ctx.rotate(-90 * Math.PI / 180); 
                    ctx.fillText('✈', 0, 2.4); 
                    state.map.addImage('plane-icon', ctx.getImageData(0,0,width,height));

                    // --- 2. INFO BOX ICON (PRE-INVERTED FOR FILTER) ---
                    const tW=100, tH=60;
                    const tCan = document.createElement('canvas');
                    tCan.width = tW; tCan.height = tH;
                    const tCtx = tCan.getContext('2d');
                    
                    // Purple line -> becomes lime after filter
                    tCtx.beginPath(); tCtx.moveTo(50,0); tCtx.lineTo(50,20);
                    tCtx.strokeStyle='#573da9'; // Purple -> lime
                    tCtx.lineWidth=2; tCtx.stroke();
                    
                    // Light box -> becomes dark after filter
                    tCtx.fillStyle='rgba(245,245,235,0.95)'; // Light -> dark
                    tCtx.strokeStyle='#573da9'; // Purple -> lime
                    tCtx.lineWidth=1.5;
                    const x=5, y=20, w=90, h=35, r=4;
                    tCtx.beginPath();
                    tCtx.moveTo(x+r, y); tCtx.arcTo(x+w, y, x+w, y+h, r);
                    tCtx.arcTo(x+w, y+h, x, y+h, r); tCtx.arcTo(x, y+h, x, y, r);
                    tCtx.arcTo(x, y, x+w, y, r); tCtx.closePath();
                    tCtx.fill(); tCtx.stroke();
                    state.map.addImage('tag-bg', tCtx.getImageData(0,0,tW,tH));
                    
                    // --- LAYERS ---
                    state.map.addSource('planes', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
                    state.map.addSource('flight-paths', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });

                    state.map.addLayer({
                        'id': 'flight-paths-layer', 'type': 'line', 'source': 'flight-paths',
                        'layout': { 'line-join': 'round', 'line-cap': 'round' },
                        'paint': { 
                            'line-color': '#000000', // Black -> white after invert -> cream after other filters
                            'line-width': 2, 
                            'line-opacity': 0.5, 
                            'line-dasharray': [2, 4] 
                        }
                    });

                    state.map.addLayer({
                        'id': 'planes-layer', 'type': 'symbol', 'source': 'planes',
                        'layout': {
                            'icon-image': 'plane-icon', 'icon-size': 1,
                            'icon-allow-overlap': true, 'icon-ignore-placement': true,
                            'icon-rotate': ['get', 'rotation'], 'icon-rotation-alignment': 'map'
                        },
                        'paint': {
                            'icon-opacity': 0.8// Matches the 80 (50% hex) in #f1f8e980
                        }
                    });

                    state.map.addLayer({
                        'id': 'info-tags', 'type': 'symbol', 'source': 'planes',
                        'layout': {
                            'icon-image': 'tag-bg', 'icon-anchor': 'top', 'icon-offset': [0, 0],
                            'icon-allow-overlap': true, 'icon-ignore-placement': true,
                            'text-field': [
                                'format',
                                ['get', 'callsign'], { 'font-scale': 0.8 }, '\n',
                                ['get', 'desc'], { 'font-scale': 0.7, 'text-color': '#573da9' } // Purple -> lime
                            ],
                            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
                            'text-anchor': 'top', 'text-offset': [0, 2.2],
                            'text-color': '#0e0716', // Dark -> light cream
                            'text-allow-overlap': true, 'text-ignore-placement': true
                        }
                    });

                    state.map.on('click', 'planes-layer', (e) => {
                        if (e.features.length > 0) selectTarget(e.features[0].properties.hex);
                    });
                    state.map.on('click', 'info-tags', (e) => {
                        if (e.features.length > 0) selectTarget(e.features[0].properties.hex);
                    });
                    state.map.on('mouseenter', 'planes-layer', () => { state.map.getCanvas().style.cursor = 'pointer'; });
                    state.map.on('mouseleave', 'planes-layer', () => { state.map.getCanvas().style.cursor = ''; });
                });

                const el = document.createElement('div');
                el.className = 'user-marker';
                state.userMarker = new maplibregl.Marker({ element: el })
                    .setLngLat([state.lon, state.lat])
                    .addTo(state.map);

            } catch (e) { console.error(e); }
        }

        async function fetchPlanes() {
            if (!state.lat) return;
            try {
                const url = `${CONFIG.API_PLANES}${state.lat}/${state.lon}/${state.radius}`;
                const res = await fetch(url);
                const data = await res.json();
                const now = Date.now();
                const activeHexes = new Set();

                if (data.ac) {
                    data.ac.forEach(p => {
                        if (!p.lat || !p.lon) return;
                        activeHexes.add(p.hex);
                        let pData = state.planesData.get(p.hex);
                        const speedKmh = (p.gs || 0) * 1.852;
                        const distanceIn5s = speedKmh * (5.5 / 3600); 
                        const projected = getProjectedPoint(p.lat, p.lon, p.track || 0, distanceIn5s);

                        if (pData) {
                            pData.startLat = pData.currentLat;
                            pData.startLon = pData.currentLon;
                            pData.targetLat = projected[1];
                            pData.targetLon = projected[0];
                            pData.startTime = now;
                            pData.alt_baro = p.alt_baro;
                            pData.gs = p.gs;
                            pData.track = p.track;
                            pData.flight = p.flight;
                            pData.t = p.t;
                            pData.baro_rate = p.baro_rate; // Store for Phase logic
                        } else {
                            pData = {
                                ...p,
                                currentLat: p.lat, currentLon: p.lon,
                                startLat: p.lat, startLon: p.lon,
                                targetLat: projected[1], targetLon: projected[0],
                                startTime: now
                            };
                            state.planesData.set(p.hex, pData);
                        }
                    });
                }
                document.getElementById('planeCountStatus').textContent = `${activeHexes.size} ACTIVE TARGETS`;
                for (let [hex, data] of state.planesData) {
                    if (!activeHexes.has(hex)) {
                        state.planesData.delete(hex);
                        if(state.selectedHex === hex) closeTarget();
                    }
                }
            } catch (e) { console.error("Plane error", e); }
        }

        function animatePlanes() {
            if (!state.map || !state.map.getSource('planes')) {
                requestAnimationFrame(animatePlanes);
                return;
            }
            const now = Date.now();
            const duration = 5000; 
            const planeFeatures = [];
            const pathFeatures = [];

            state.planesData.forEach((p, hex) => {
                const elapsed = now - p.startTime;
                let progress = elapsed / duration;
                if (progress > 1) progress = 1;

                p.currentLat = p.startLat + (p.targetLat - p.startLat) * progress;
                p.currentLon = p.startLon + (p.targetLon - p.startLon) * progress;

                // Format Tag Data
                const callsign = p.flight ? p.flight.trim() : p.hex;
                const alt = p.alt_baro === 'ground' ? 'GND' : Math.round(p.alt_baro/100)*100;
                const spd = Math.round(p.gs || 0);
                const desc = `${alt}ft ${spd}kt`;

                // 1. Plane
                planeFeatures.push({
                    'type': 'Feature',
                    'geometry': { 'type': 'Point', 'coordinates': [p.currentLon, p.currentLat] },
                    'properties': { 
                        'hex': hex, 
                        'rotation': p.track || 0,
                        'callsign': callsign,
                        'desc': desc
                    }
                });

                // 2. Path (ONLY IF NOT GROUND)
                if (p.alt_baro !== 'ground') {
                    const speedKmh = (p.gs || 0) * 1.852;
                    const dist2Min = speedKmh * (2 / 60); 
                    const futurePos = getProjectedPoint(p.currentLat, p.currentLon, p.track || 0, dist2Min);
                    
                    pathFeatures.push({
                        'type': 'Feature',
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [[p.currentLon, p.currentLat], [futurePos[0], futurePos[1]]]
                        }
                    });
                }

                if (state.selectedHex === hex) {
                    const dist = calcDist(state.lat, state.lon, p.currentLat, p.currentLon);
                    document.getElementById('tDist').textContent = dist.toFixed(2);
                }
            });

            state.map.getSource('planes').setData({ 'type': 'FeatureCollection', 'features': planeFeatures });
            state.map.getSource('flight-paths').setData({ 'type': 'FeatureCollection', 'features': pathFeatures });

            requestAnimationFrame(animatePlanes);
        }

        function selectTarget(hex) {
            const p = state.planesData.get(hex);
            if(!p) return;
            state.selectedHex = hex;
            document.getElementById('targetCard').classList.add('active');
            if(state.map) state.map.flyTo({ center: [p.currentLon, p.currentLat], zoom: 13, speed: 1.2 });
            document.getElementById('tCall').textContent = p.flight ? p.flight.trim() : p.hex;
            document.getElementById('tType').textContent = p.t || "UNKNOWN";
            document.getElementById('tAlt').textContent = p.alt_baro === 'ground' ? 'GND' : p.alt_baro;
            document.getElementById('tSpd').textContent = Math.round(p.gs || 0);
            document.getElementById('tHdg').textContent = Math.round(p.track || 0).toString().padStart(3,'0');
            
            const phase = getFlightPhase(p);
            document.getElementById('tPhase').textContent = phase;

            announce(p, phase);
        }

        function closeTarget() {
            state.selectedHex = null;
            document.getElementById('targetCard').classList.remove('active');
            if(state.map) state.map.flyTo({ center: [state.lon, state.lat], zoom: getZoomForRadius(state.radius) });
        }

        function getFlightPhase(p) {
            if (p.alt_baro === 'ground') return 'TAXIING';
            const rate = p.baro_rate || 0;
            if (rate > 500) return 'CLIMBING';
            if (rate < -500) return 'DESCENDING';
            return 'CRUISING';
        }

        function speak(text) {
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 1.1;
            window.speechSynthesis.speak(u);
        }

        function announce(p, phase) {
            const call = (p.flight || "Target").split('').join(' ');
            const dist = Math.round(calcDist(state.lat, state.lon, p.currentLat, p.currentLon));
            speak(`Callsign ${call}. ${dist} miles. ${phase}.`);
        }

        function updateWeather() {
            if (!state.lat) return;
            fetch(`${CONFIG.API_WX_POINTS}${state.lat},${state.lon}`)
                .then(r => r.json())
                .then(d => fetch(d.properties.observationStations))
                .then(r => r.json())
                .then(d => fetch(d.features[0].id + '/observations/latest'))
                .then(r => r.json())
                .then(d => {
                    const p = d.properties;
                    const tempF = Math.round((p.temperature.value * 9/5) + 32);
                    const wind = Math.round(p.windSpeed.value * 0.539957);
                    document.getElementById('wxTemp').textContent = `${tempF}°`;
                    document.getElementById('wxCond').textContent = (p.textDescription || "Clear").toUpperCase();
                    document.getElementById('wxWind').textContent = wind;
                }).catch(e => console.log("WX Error"));
        }

        function setRadius(r) {
            state.radius = r;
            document.querySelectorAll('.radius-opt').forEach(el => el.classList.remove('selected'));
            fetchPlanes();
            if(state.map) state.map.setZoom(getZoomForRadius(r));
            toggleSettings();
        }
        function toggleSettings() { document.getElementById('settingsPanel').classList.toggle('open'); }
        function getZoomForRadius(r) { if(r<=3) return 13; if(r<=5) return 12; if(r<=10) return 11; return 9; }
        
        function getProjectedPoint(lat, lon, bear, distKm) {
            const R = 6371; 
            const d = distKm / R;
            const rLat = lat * Math.PI / 180;
            const rLon = lon * Math.PI / 180;
            const rBear = bear * Math.PI / 180;
            const nLat = Math.asin(Math.sin(rLat) * Math.cos(d) + Math.cos(rLat) * Math.sin(d) * Math.cos(rBear));
            const nLon = rLon + Math.atan2(Math.sin(rBear) * Math.sin(d) * Math.cos(rLat), Math.cos(d) - Math.sin(rLat) * Math.sin(nLat));
            return [nLon * 180 / Math.PI, nLat * 180 / Math.PI];
        }
        function calcDist(lat1, lon1, lat2, lon2) {
            const R = 3958.8;
            const dLat = (lat2-lat1)*Math.PI/180;
            const dLon = (lon2-lon1)*Math.PI/180;
            const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }
        document.getElementById('settingsBtn').onclick = toggleSettings;
    </script>
</body>
</html>